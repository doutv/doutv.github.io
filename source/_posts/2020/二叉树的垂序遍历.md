---
title: 二叉树的垂序遍历
date: 2020-07-04 00:12:34
tags: 
    - Algorithm
    - Leetcode
    - STL
    - Tree
mathjax: true
---

偶然打开[面试页面](https://leetcode-cn.com/interview/)发现的一道好题：[二叉树的垂序遍历](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/)


<!-- more -->

# 思路
1. 一开始看题，很简单嘛，dfs走起，算出每个点的X，加到数组里面就完事了，而且树的结点数介于 1 和 1000 之间，开个`vector<int> res[2005]`即可
2. 提交后发现不对劲，原来还有一个条件：如果两个结点位置相同，则首先报告的结点值较小。
3. 想了一想，直觉判断一波，同一层（Y相等）最多存在2个点的X相等，那改成bfs就好了啊，层序遍历
```cpp
while (!q.empty())
{
    auto [x,y,cur]=q.front();
    q.pop();
    if (cur==nullptr)
        continue;
    auto [nx,ny,nxt]=q.front();
    if (nxt!=nullptr&&x==nx&&y==ny)
    {
        q.pop();
        ans[x+1000].push_back(min(cur->val,nxt->val));
        ans[x+1000].push_back(max(cur->val,nxt->val));
        q.push({x-1,y+1,cur->left});
        q.push({x+1,y+1,cur->right});
        q.push({x-1,y+1,nxt->left});
        q.push({x+1,y+1,nxt->right});
        continue;
    }
    ans[x+1000].push_back(cur->val);
    q.push({x-1,y+1,cur->left});
    q.push({x+1,y+1,cur->right});
}
```
4. 交上去还是不对，想了想，原来是bfs有点小问题，同一层两个X相等的点并不一定相邻，中间可能隔了空节点。所以要保证队列中的节点不是空节点
5. 加完特判之后还是不对，再看了看错了的那组数据，原来同一层可以存在多个（>2）点的X相等，于是滚去看题解了~
6. 最后在评论区发现一种比较简洁的[解法](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/comments/364408)，`map`里面套一个`set`，当然`map`也可以换成`array`。关键是`set`中存储的元素是由`node->val`与`y`拼接而成的，起到了先按`y`升序排序，再按`val`升序排序的作用，十分巧妙且运行速度很快。
7. 最终代码：
```cpp
class Solution {
public:
    map<int,set<int>> m;
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        queue<tuple<int,int,TreeNode*>> q;
        q.push({0,0,root});
        while (!q.empty())
        {
            auto [x,y,cur]=q.front();
            q.pop();
            if (cur==nullptr)
                continue;
            m[x].insert(y*10000+cur->val);
            q.push({x-1,y+1,cur->left});
            q.push({x+1,y+1,cur->right});
        }
        vector<vector<int>> ans;
        for (auto each:m)
        {
            vector<int> tmp;
            for (auto y:each.second)
                tmp.push_back(y%10000);
            ans.push_back(tmp);
        }
        return ans;
    }
};
```