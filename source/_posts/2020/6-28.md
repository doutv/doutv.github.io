---
layout: hexo
title: 6.28 Notes
date: 2020-06-28 12:00:28
tags: 
    - Algorithm
    - Leetcode
---

# 6.22-6.28 Learning Notes

# Leetcode
# [MST](https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/)
请你找到给定图中最小生成树的所有关键边和伪关键边。如果最小生成树中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。

题目数据范围很小，可以暴力判断每条边是关键边/伪关键边/其他的。

[[参考题解](https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution/shan-chu-bian-yu-jia-ru-bian-zui-xiao-sheng-cheng-/)

1. 先求MST。
2. 对于原图中的每条边：
   1. 如果边在MST中，计算去掉该边后的MST权值，如果比原来的大，那么当前边是伪关键边；如果相等，那么它是关键边。
   2. 如果边不在MST中，计算强制加入当前边后的MST权值，如果相等，则当前边是伪关键边。
## code
```cpp
class Solution
{
public:
    class Graph
    {
    public:
        struct Edge
        {
            int u, v, w;
            int num;
        } e[205];
        bool inmst[205];
        int size;
        Graph() { size = 0; };
        static bool cmp(Edge a, Edge b)
        {
            return a.w < b.w;
        }
        void addedge(int u, int v, int w)
        {
            ++size;
            e[size].u = u;
            e[size].v = v;
            e[size].w = w;
            e[size].num = size - 1;
            inmst[size] = 0;
        }
        void sorted()
        {
            sort(e + 1, e + size + 1, cmp);
        }
    };
    Graph G;
    int fa[105];
    int find(int x)
    {
        if (x != fa[x])
            fa[x] = find(fa[x]);
        return fa[x];
    }
    void combine(int x, int y)
    {
        int xx = find(x);
        int yy = find(y);
        if (xx != yy)
            fa[xx] = yy;
    }
    int include_mst_weight(int inc, int n)
    {
        int mstw = 0;
        int cnt = 1;
        for (int i = 0; i < n; i++)
            fa[i] = i;
        int u = G.e[inc].u;
        int v = G.e[inc].v;
        int w = G.e[inc].w;
        if (find(u) != find(v))
        {
            combine(u, v);
            ++cnt;
            mstw += w;
        }
        for (int i = 1; i <= G.size; i++)
        {
            if (i == inc)
                continue;
            int u = G.e[i].u;
            int v = G.e[i].v;
            int w = G.e[i].w;
            if (find(u) != find(v))
            {
                combine(u, v);
                ++cnt;
                mstw += w;
            }
            if (cnt == n)
                break;
        }
        if (cnt < n)
            mstw = INT32_MAX;
        return mstw;
    }
    int exclude_mst_weight(int exc, int n)
    {
        int mstw = 0;
        int cnt = 1;
        for (int i = 0; i < n; i++)
            fa[i] = i;
        for (int i = 1; i <= G.size; i++)
        {
            if (i == exc)
                continue;
            int u = G.e[i].u;
            int v = G.e[i].v;
            int w = G.e[i].w;
            if (find(u) != find(v))
            {
                combine(u, v);
                ++cnt;
                mstw += w;
            }
            if (cnt == n)
                break;
        }
        if (cnt < n)
            mstw = INT32_MAX;
        return mstw;
    }
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>> &edges)
    {
        for (int i = 0; i < n; i++)
            fa[i] = i;
        for (auto each : edges)
        {
            G.addedge(each[0], each[1], each[2]);
        }
        G.sorted();
        int mstw = 0;
        int cnt = 1;
        for (int i = 1; i <= G.size; i++)
        {
            int u = G.e[i].u;
            int v = G.e[i].v;
            int w = G.e[i].w;
            if (find(u) != find(v))
            {
                combine(u, v);
                mstw += w;
                G.inmst[i] = 1;
                ++cnt;
            }
            if (cnt == n)
                break;
        }
        vector<int> key_edge;
        vector<int> fkey_edge;
        for (int i = 1; i <= G.size; i++)
        {
            if (G.inmst[i])
            {
                int new_mstw = exclude_mst_weight(i, n);
                if (new_mstw > mstw)
                    key_edge.push_back(G.e[i].num);
                else
                    fkey_edge.push_back(G.e[i].num);
            }
            else
            {
                int new_mstw = include_mst_weight(i, n);
                if (new_mstw == mstw)
                    fkey_edge.push_back(G.e[i].num);
            }
        }
        return {key_edge, fkey_edge};
    }
};
```