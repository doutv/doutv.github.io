---
title: 子矩阵
date: 2020-07-05 13:59:36
tags:
    - Algorithm
    - Leetcode
    - dp
---

[5454. 统计全 1 子矩形](https://leetcode-cn.com/problems/count-submatrices-with-all-ones/)

给你一个只包含 0 和 1 的 rows * columns 矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。

<!-- more -->

1. 这题比较像dp（直觉），矩形这类问题挺套路的，基本状态定义都是以当前坐标为右下角
2. 二维的情况不好入手，那我就先从一维的情况开始想：`dp[i]`表示以`mat[i]`为最右侧矩形的全为1的子矩形个数，$dp[i]=\sum_{i=1}^{dp[i-1]} if \quad mat[i]=1,dp[i]=0 \quad if \quad mat[i]=0$
3. 但是这个结论似乎无法推广到二维，于是我又想到了另一种方法：
   1. 先从宽为1的矩形出发，$rowdp[i][j]$表示以$(i,j)$为最右侧的矩形的最大长度（最大矩形为$1 \times rowdp[i][j]$，$coldp[i][j]$表示以$(i,j)$为底部的矩形的最大高度（最大矩形为$coldp[i][j] \times 1$）。基本的框架是这样的：
   ```
    for range(rowdp[i][j]):
        using coldp to update ans
    ```
    1. 最好画下图来理解整个过程。想象有一条线从第$j$列出发，一直向左扫，扫到第$rowdp[i][j]$列结束。实际上是扫过了所有可能的子矩形的左上角，而通过$coldp[i][k]$我们可以得到位于第$k$列的左上角。$mincol$代表到第$k$列为止的最小高度，且最大矩形的高度为$mincol$
4. 代码：
```cpp
class Solution
{
public:
    static const int M = 155;
    int rowdp[M][M];
    int coldp[M][M];
    int numSubmat(vector<vector<int>> &mat)
    {
        int n = mat.size();
        int m = mat[0].size();
        int ans = 0;
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (mat[i][j] == 0)
                {
                    rowdp[i][j] = 0;
                    coldp[i][j] = 0;
                    continue;
                }
                int prerowdp = j ? rowdp[i][j - 1] : 0;
                int precoldp = i ? coldp[i - 1][j] : 0;
                rowdp[i][j] = prerowdp + 1;
                coldp[i][j] = precoldp + 1;
                int mincol = M;
                for (int k = 0; k < rowdp[i][j]; k++)
                {
                    mincol = min(mincol, coldp[i][j - k]);
                    ans += mincol;
                }
            }
        }
        return ans;
    }
};
```
 

我看到评论区推荐了两道相似题目：
- [1277. 统计全为 1 的正方形子矩阵](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)
  - 这题小改一下代码就AC了
    ```cpp
    for (int k = 0; k < rowdp[i][j]; k++)
    {
        mincol = min(mincol, coldp[i][j - k]);
        if (mincol>=k+1)
            ++ans;
        else
            break;
    }
    ```
- [1074. 元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)
